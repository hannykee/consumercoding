군집분석 for 시장세분화/ 시장 내 경쟁구조분석 사용
#유사성이란? 거리가 가까운 개체

가] 계층적 군집(데이터가 많으면 핸들링 불가능-나무모양)
  ==> Ward결합법 (,단일결합법,완전결합법,평균결합법)
나] 비계층적 군집(*실제사용- 군집의 수를 미리 정하고, 군집의 중심을 임의로 선택함)
  ==> k-menas 방법 (k-median방법)   (cf, 군집의 중심을 means로 하느냐 median으로 하느냐)
                                    #outlier의 영향이 큰 표본의 경우 median으로 사용
* 군집의 수를 여러개 돌려보고 가장 합리적인 것을 선택했다는 논거가 필요함.

#계층적 군집을 먼저 돌려보고 대략적인 군집의 수를 파악하고 = > 비계층적 분석 사용\
*군집분석-> n을 묶음, 요인분석=> 변수 x를 묶음


가_계층적 군집 덴드로그램
내가 원하는 부분에서 군집을 나눌 수 있음, (위에서부터 내려와서 최종적으로는 하나로 묶임)
##주의할 점 : 군집의 거리 계산하는 방법이 다르다.=> 그 다음에 거리가 가까운 것끼리 붙임
거리계산법의 차이
1) 단일계산법; 가장 가까운
2) 완전게산법; 가장 먼
3) 평균계산법: 원투원 매칭의 거리의 평균 구함
4) 편차의 제곱을 군집을 구성하는 대상들에 걸쳐 합한 것을 사용


나_비계층적 군집방법
사전에 정해진 군집 개수,
초기 군집중심(centroid) 임의로 선택
각 관측값들을 가장 가까운 군집 중심에 할당하여 최초의 군집 형성,
중심 하나 만든다. 가까운 녀석 붙인다. 다시 중심을 계산한다. 가까운 녀석 붙이기...수렴할 때 까지
1)k-means 방법 대부분사용 (이상치 선별과정을 거친 후 한다.)
2)k-median 방법 (잘 안쓰지만 이상치가 이을 때)



군집분석 과정
1) 데이터를 군집화하는데 중요하다고 판단되는 속성들을 선택****
  #SELECT
2) 데이터 표준화(변수 범위를 맞춰주는 과정이다)
  #  scale(데이터이름)
3) 이상치 선별
  #filter   is.na....등등 사용
4)거리 측정 단계 *default 값은 "eucliean"방법이다.(유클리디안거리 사용   루트 (b2-b1)2+(a2-a1)2
  #dist(데이터이름,method="euclidean")
)5)군집알고리즘을 선택 (계층적- 종류/비계층적)
hclust (데이터이름, method="방법")   *계층적 분석 명령어
6) 최종 군집 개수에 따라 군집 결과를 해석( 관측치 간 공통점, 타군집과 차이)
덴드로그램 그리기
par(mfrow=c(2,2)) #그림 한눈에 보더라
7) 비계층적 방법으로 다시 수행하려면 K-MEANS로 본다.



setwd("c:/data")
fact_data=read.csv("clust_data.csv",header=T)
#원하는 속성만 골라내기(filter)
fact_data
#단위표준화
scale(데이터이름)
#거리계산-거리 행렬 만들기
dis_data=dist(fact_data,method="euclidean")
#계층적 방법 중 방식 선택
hc_sl=hclust(dis_data,method="single")
hc_co=hclust(dis_data,method="complete")
hc_av=hclust(dis_data,method="average")
hc_wd=hclust(dis_data,method="ward.D")
#군집 확인하기 
par(mfrow=c(2,2))  #그래프를 4개 그릴 것이다 공간 미리 할당
plot(hc_sl,hang=-1)   #덴드로그램 그려주는 함수 hang은 
rect.hclust(hc_sl,k=3,border="red")
계층적 분석을 k가 3개의 군집(*내가설정)으로 나오는 빨갛게 네모로 만들어라. ( 군집 구분해주기)

plot(hc_co,hang=-1)
rect.hclust(hc_co,k=3,border="red")

plot(hc_av,hang=-1)
rect.hclust(hc_av,k=3,border="red")

plot(hc_wd,hang=-1)
rect.hclust(hc_wd,k=3,border="red")
#와드의 장점은 편차의 제곱이기 때문에 균형 잡힌 클러스터가 나옴

)()

<비계층적방법>)
#군집 분석은 흠 잡을데 없는 분석은 아니다. 

#시작 값을 고정시켜놓고 시작( 군집 분석에 정답은 없다. ) = kmeans를 돌리기 전에
set.seed(1234)
#군집분석 실시, k값 정해줌
nc_kmeans=kmeans(fact_data,3)
nc_kmeans
#결과해석

가]클러스터가 몇개로 나뉘어짐 3개로 6개 7개 7개

나]최종 군집중심값==> 각 그룹의 특성 파악 ******매우 중요
1클러스터 (가격을 제외하고 모두 크다. => 가격에 대한 민감도가 거의 없고 나머지를 중요하게 생각하는 그룹-고품질 속설 중시)
2클러스터 (영양가 저칼로리에 관심 없고, 맛.갈증해소.청량감.분위기가 중요한 그룹- 음료수 자체의 가치를 높게 평가)
3클러스터 (가격이 제일 중요한 그룹)

다] n의 클러스터 소속 정보
clustering vector 20명이 어떤 클러스터에 소속되어 있는지 알려줌

그 뒤는 해석할 필요가 없음
(제곱합 계산)
(availabe components 내가 확인할수도 있는 값 설명)
nc_kmeans$size #(각 클러스터 별 컴포넌트 수)
nc_kmeans$iter #(반복 ) 두 번 만에 수렴되었다.


#####################클러스터로 변수 추가만들기  => 인구통계학적 변수 확인하기
fact_data$cluster=nc_kmeans$cluster 
#이를 데이터로 만들어주기
write.csv(fact_data,"newcluster.csv")

#이를 파이프 연산자로 분석